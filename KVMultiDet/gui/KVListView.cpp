/*
$Id: KVListView.cpp,v 1.6 2009/04/28 09:11:29 franklan Exp $
$Revision: 1.6 $
$Date: 2009/04/28 09:11:29 $
*/

//Created by KVClassFactory on Wed Apr  9 11:51:38 2008
//Author: franklan

#include "KVListView.h"
#include "TGButton.h"
#include "TVirtualX.h"

ClassImp(KVListView)


KVListView::KVListView(TClass* obj_class, const TGWindow* p, UInt_t w, UInt_t h,
                       UInt_t options,
                       Pixel_t back)
   : TGListView(p, w, h, options, back), nselected(0), fObjClass(obj_class)
{
   // Create list view widget for objects of class obj_class.
   // A KVLVContainer object is also created and set as the container in use.
   // The view mode is set to kLVDetails (only one possible, no icons)
   // Scrolling increments are set to 1 (vertical) & 19 (horizontal)

   SetContainer(new KVLVContainer(this, kHorizontalFrame, fgWhitePixel));
   SetViewMode(kLVDetails);
   SetIncrements(1, 19);
   fMaxColumnSize = 100;
   fContextMenu = new TContextMenu("fCurrentContext");
   ((KVLVContainer*)GetContainer())->SetObjClass(fObjClass);
}

Bool_t KVListView::ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2)
{
   // Handle messages generated by the list view container
   switch (GET_SUBMSG(msg)) {
      case kCT_SELCHANGED:
         // only emit signal if number selected has really changed
         if ((int)parm2 != nselected) {
            nselected = (int)parm2;
            SelectionChanged();
         }
         return kTRUE;
         break;
      default:
         break;
   }
   return TGCanvas::ProcessMessage(msg, parm1, parm2);
}

void KVListView::ActivateSortButtons()
{
   // Connects the column header buttons (if defined) to the container's
   // Sort(const Char_t*) method. Each button, when pressed, sends a "Clicked"
   // signal which activates "Sort" with the name of the button/column as argument.

   TGTextButton** buttons = GetHeaderButtons();
   if (buttons) {
      for (int i = 0; i < (int)GetNumColumns(); i++) {
         buttons[i]->Connect("Clicked()", "KVLVContainer",
                             GetContainer(), Form("Sort(=%d)", i));
      }
   }
}

void KVListView::SetDataColumns(Int_t ncolumns)
{
   TGListView::SetHeaders(ncolumns);
   ((KVLVContainer*)GetContainer())->SetDataColumns(ncolumns);
}

void KVListView::SetDataColumn(Int_t index, const Char_t* name, const Char_t* method,
                               Int_t mode)
{
   // Define column with index = 0, 1, ...
   // name = name of column (shown in column header button)
   // method = method to call to fill column with data (by default, "Getname")
   // mode = text alignment for data in column (kTextCenterX [default], kTextLeft, kTextRight)
   // column header name is always center aligned
   SetHeader(name, kTextCenterX, mode, index);
   ((KVLVContainer*)GetContainer())->SetDataColumn(index, fObjClass, name, method);
}

Int_t KVListView::GetColumnNumber(const Char_t* colname)
{
   // Returns index of data column from its name.
   // Return -1 if not found.

   for (Int_t idx = 0; idx < fNColumns - 1; idx++) {
      if (fColHeader[idx]) {
         if (fColNames[idx] == colname) return idx;
      }
   }
   return -1;
}

//______________________________________________________________________________

void KVListView::SetDefaultColumnWidth(TGVFileSplitter* splitter)
{
   // Set default column width of the columns headers.
   // Limit minimum size of a column to total width / number of columns
   // If only one column it will span the whole viewport

   TGLVContainer* container = (TGLVContainer*) fVport->GetContainer();

   if (!container) {
      Error("SetDefaultColumnWidth", "no listview container set yet");
      return;
   }
   container->ClearViewPort();
   UInt_t minWidth = container->GetPageDimension().fWidth / (fNColumns - 1);

   for (int i = 0; i < fNColumns; ++i) {
      if (fSplitHeader[i] == splitter) {
         TString dt = fColHeader[i]->GetString();
         UInt_t bsize = gVirtualX->TextWidth(fColHeader[i]->GetFontStruct(),
                                             dt.Data(), dt.Length());
         UInt_t w = TMath::Max(fColHeader[i]->GetDefaultWidth(), bsize + 20);
         if (i == 0) {
            //w = TMath::Max(fMaxSize.fWidth + 10, w);
            w = TMath::Max(w, minWidth);
         }
         if (i > 0)  {
            w = TMath::Max(container->GetMaxSubnameWidth(i) + 40, (Int_t)w);
            //printf("w=%ud\n",w);
            //w = TMath::Min(w, fMaxColumnSize);
            w = TMath::Max(w, minWidth);
         }
         fColHeader[i]->Resize(w, fColHeader[i]->GetHeight());
         Layout();
      }
   }
}

void KVListView::SetUseObjLabelAsRealClass(Bool_t yes)
{
   // If list contains KVBase-derived objects, calling this method with yes=kTRUE
   // will cause the string returned by the objects' KVBase::GetLabel() method
   // to be used as the class name of the object
   ((KVLVContainer*)GetContainer())->SetUseObjLabelAsRealClass(yes);
}

//______________________________________________________________________________

void KVListView::SetDoubleClickAction(const char* receiver_class, void* receiver, const char* slot)
{
   // Overrides the default 'double-click' action.
   // By default, double-clicking on an object in the list will call the Browse(TBrowser*)
   // method of the selected object.
   // Use this method to override this behaviour.
   // When an object is double-clicked the method 'slot' of the object 'receiver' of class
   // 'receiver_class' will be called. The method in question must have the signature
   //       receiver_class::slot(TObject*)
   // The address of the selected (T)object is passed as argument.

   ((KVLVContainer*)GetContainer())->SetDoubleClickAction(receiver_class, receiver, slot);
}

void KVListView::AddContextMenuClassException(TClass* cl)
{
   // The global context menu status (allowed or not allowed) is set by AllowContextMenu().
   // If required, this can be overridden for specific classes by calling this
   // method for each required class.
   // In this case, any objects in the list of precisely this class (not derived classes)
   // will have the opposite behaviour to that defined by AllowContextMenu(),
   // i.e. if context menus are globally disabled, this method defines the classes for
   // which a context menu is authorised, and vice-versa.

   ((KVLVContainer*)GetContainer())->AddContextMenuClassException(cl);
}

