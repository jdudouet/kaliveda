% KaliVeda User's Guide

# Particle identification #

Particle identification in KaliVeda is handled by the [KVIDTelescope] class family.
A basic [KVIDTelescope] associates 2 successive detectors on any of the particle trajectories through
the array which in principle can provide $\Delta E$-$E$ identification.
Specialised classes are available to handle single-detector identification methods as required (such as PSA
in silicon detectors [KVFAZIAIDSiPSA], or fast-slow identification in CsI(Tl) crystals [KVIDINDRACsI]).

The actual identification procedure can be handled in different ways, but the method which
attempts to identify whatever passed through the detector(s) is

~~~~~~~~~{.cpp}
KVIDTelescope::Identify(KVIdentificationResult*, Double_t x=-1, Double_t y=-1)
~~~~~~~~~

`x` and `y` here refer to coordinates in a 2-D identification map (for $\Delta E$-$E$ identification
we would have `x`=$E$ and `y`=$\Delta E$). The results of the identification attempt are returned
in the [KVIdentificationResult] object passed as first argument. This is a very detailed report on
how well (or not) the identification went (see class reference page [KVIdentificationResult] for details).

As the `x` and `y` arguments have default values, this method can be called without providing their
values, and indeed this is how it is used most of the time. In this case the methods

~~~~~~~~~{.cpp}
KVIDTelescope::GetIDGridCoords(Double_t& X, Double_t& Y, KVIDGraph* grid)
KVIDTelescope::GetIDGridXCoord(KVIDGraph* grid)
KVIDTelescope::GetIDGridYCoord(KVIDGraph* grid)
~~~~~~~~~

are used to provide the coordinates for the identification map. As will be seen below, the values to
be used for the coordinates are automatically computed even if several identification grids are assigned
to the same telescope.

## Identification grids ##

The most common way of implementing the identification of particles is by defining identification grids,
which are a collection of lines and contours in a 2-D map which can be used to reject or accept particles,
assign them a value of $Z$ and/or $A$, depending on where they fall in the map, and this in turn depends
on how we assign $(x,y)$ coordinates to each particle. 

### X- and Y-coordinates (`VARX`,`VARY`) ###

This decision is made when histograms are prepared
from data in order to draw the identification grid. Naively, for a simple $\Delta E$-$E$ telescope,
one would think to fill this histogram as follows:

~~~~~~~~~{.cpp}
// supposing TH2F* myhisto (pointer to predefined 2-D histogram)
// and KVIDTelescope* idt (pointer to current DE-E identification telescope)
myhisto->Fill(idt->GetDetector(2)->GetDetectorSignalValue("Energy"),
   idt->GetDetector(1)->GetDetectorSignalValue("Energy"));
~~~~~~~~~

using the calibrated energy of each of the two detectors (see [Detector signals and calibrations]).
However this is unlikely and discouraged for two reasons:

  * we don't want to wait for detector calibration before implementing the identifications
  * if we use a calibration to set up identification maps, what happens if the calibrations are later changed? Redo the identification!
  
One is therefore more likely to use some 'raw' data signal for each detector, or a combination of them (the following
example is just to illustrate the possibilities, not a serious suggestion):

~~~~~~~~~{.cpp}
double X = idt->GetDetector(2)->GetDetectorSignalValue("Q3.Amplitude")
              /idt->GetDetector(2)->GetDetectorSignalValue("Q3.RiseTime");
double Y = idt->GetDetector(1)->GetDetectorSignalValue("Q2.FPGAEnergy")
              +idt->GetDetector(1)->GetDetectorSignalValue("I2.Amplitude");
myhisto->Fill(X,Y);
~~~~~~~~~

assuming of course that all of the above signals exist for each of the two detectors (see [Detector signals and calibrations]).

Next you draw your grid(s), and as long as you define the `VARX`, `VARY` parameters (using the graphical interface,
[KVIDGridEditor]) to be

~~~~~~~~~~
VARX : Q3.Amplitude/Q3.RiseTime
VARY : Q2.FPGAEnergy+I2.Amplitude
~~~~~~~~~~

then when the grid will be loaded by the identification telescope using

~~~~~~~~~~{.cpp}
// assuming KVIDGraph* mygrid is a pointer to your grid
idt->SetGrid(mygrid);
~~~~~~~~~~

the default `GetIDGridCoords` methods of [KVIDTelescope] will automatically return the
correct values for your grid, according to the expressions in `VARX` and `VARY`.

### Multiple grids for the same telescope ###
Some identifications require several grids for them to be correctly handled: for example, when
high gain and low gain signals are available for one or both of the detectors concerned.
This can be handled by [KVIDTelescope], you just need to give the order in which the grids
should be tried in an environment variable (`.kvrootrc` file):

~~~~~~~~~~
[dataset].[array name].[ID type].GridOrder:    [VARY1]_[VARX1],[VARY2]_[VARX2],[VARY3]_[VARX3],...

#Example:
INDRAFAZIA.E789.FAZIA.Si-Si.GridOrder:   QL1.Amplitude_Q2.FPGAEnergy,QH1.FPGAEnergy_Q2.FPGAEnergy
~~~~~~~~~~

Identification with each grid will be attempted in the order given; the first successful identification
(with quality code < 4; see [KVIDZAGrid]) will be accepted.

[KVIDTelescope]: http://indra.in2p3.fr/kaliveda/doc/CLASS_DOC_BRANCH/classKVIDTelescope.html
[KVGeoDNTrajectory]: http://indra.in2p3.fr/kaliveda/doc/CLASS_DOC_BRANCH/classKVGeoDNTrajectory.html
[KVFAZIAIDSiPSA]: http://indra.in2p3.fr/kaliveda/doc/CLASS_DOC_BRANCH/classKVFAZIAIDSiPSA.html
[KVIDINDRACsI]: http://indra.in2p3.fr/kaliveda/doc/CLASS_DOC_BRANCH/classKVIDINDRACsI.html
[KVIdentificationResult]: http://indra.in2p3.fr/kaliveda/doc/CLASS_DOC_BRANCH/classKVIdentificationResult.html
[Detector signals and calibrations]: calibrations.html
[KVIDGridEditor]: http://indra.in2p3.fr/kaliveda/doc/CLASS_DOC_BRANCH/classKVIDGridEditor.html
[KVIDZAGrid]: http://indra.in2p3.fr/kaliveda/doc/CLASS_DOC_BRANCH/classKVIDZAGrid.html
