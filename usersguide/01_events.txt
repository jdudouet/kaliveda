% KaliVeda User's Guide

# Multi-body Events #

The main business of KaliVeda is the analysis of multi-body events produced in heavy-ion reactions,
therefore it is no surprise that a central role is played by the class [KVEvent] which can be thought of as a container class for particles and nuclei (see [Particles] & [Nuclei]).
In fact there are two more event containers which are derived from [KVEvent], the full list is:

 - [KVEvent]: base class for multi-body events (container for [KVNucleus] objects);
 - [KVSimEvent]: base class for simulated multi-body events (container for [KVSimNucleus] objects);
 - [KVReconstructedEvent]: base class for reconstructed multi-body events, either experimental data or the result of ["filtering"][Filter] some simulated data (container for [KVReconstructedNucleus] objects);

In addition to containing a list of particles/nuclei, each event class also has in common the following functionality:

 - an associated list of parameters, accessible through the `GetParameters()` and `SetParameter()` methods;
 - iterators for looping over all or a subset of the particles of the event;
 - methods for defining named subsets ('groups') of particles according to various selection criteria;
 - methods for defining/modifying different relativistic reference frames in which to 'view' the particles of the event

Let us mention in passing the associated [KVEventViewer] class which can be used to produce 3D images of events using the ROOT OpenGL backend.

## Notes on usage

### Object ownership

Events are built up by repeated calls to the `AddParticle()` method which creates a new particle object (derived from `KVNucleus`), adds it to the event, and returns a pointer to the new particle.
All particles in an event __belong__ to the event and are destroyed by the `KVEvent` destructor.

Therefore a `KVEvent` cannot be used to store references to particles in another `KVEvent` object,
for example if one wants to handle a subset of the particles in the event. This is why the iterators
allow to iterate only over selected subsets of particles if required.

### Storing references to particles in an event

If you really need to store a list of references to some particles in an event, you can use an STL container, `TCollection` or [KVSeqCollection] collection class to store the particle pointers, as long as the collection does not try to delete the objects when it goes out of scope (e.g. don't use [KVList] which owns its objects by default).

### Making a copy of all or part of an event

You can if you wish copy all or part of an event, as long as you understand that the particles in the copy will be new independent objects; they will not change if you change the original event after the copy (there may also be unwanted side-effects especially for [KVReconstructedNucleus] particles).


~~~~~~~~~{.cpp}
// 'event' is a KVEvent we want to copy into new event 'event2'
KVEvent event2;
for(KVEvent::Iterator it = event.begin(); it != event.end(); ++it){
   (*it).Copy( *(event2.AddParticle()) );
}
~~~~~~~~~

### Merging several events into one

Although it is difficult/unwise to separate events into subevents, on the other hand it is possible to merge several event fragments into one single event:

~~~~~~~~~{.cpp}
// 'event_list' is a TList (for example) containing KVEvent objects to merge
KVEvent merged_event;
merged_event.MergeEventFragments(&event_list);
~~~~~~~~~

**WARNING** after merging, the subevents in the list will be empty and useless. Do not try to use them after merging!

## Iterating over particles in events

### Using `KVEvent::Iterator` iterators

Just as for STL containers, [KVEvent] provides `begin()` and `end()` methods which can be used to iterate over the particles of the event. The iterator class is [KVEvent::Iterator]:

~~~~~~~~~{.cpp}
for(KVEvent::Iterator it = event.begin(); it != event.end(); ++it){
   (*it).Print();
}

// with C++11 or later:
for(auto& n : event){
   n.Print();
}
~~~~~~~~~

The basic iterator shown above will iterate over all particles of the event. As [KVEvent::Iterator] is fully STL-compliant, you can use it with the (non-modifying) functions defined in the [std::algorithm library], as well as in a [range-based for loop] (from C++11 onwards).

#### Iterators for derived classes

The iterator dereference operator, i.e. `(*it)` in the previous example, returns a `KVNucleus&` reference (this is also the type of the `auto` variable `n` in the C++11 version). This is also the case for iterators of derived classes, e.g. although you can write

~~~~~~~~~{.cpp}
for(KVReconstructedEvent::Iterator it = reconEvent.begin(); it != reconEvent.end(); ++it){
~~~~~~~~~

assuming that `reconEvent` is a `KVReconstructedEvent` object, the iterator `it` will in fact be no different to a `KVEvent::Iterator` and `*it` will not return a `KVReconstructedNucleus&` reference.

In order to access methods which are specific to derived particle classes you can use the following methods which return a pointer or reference of the desired type:

~~~~~~~~~{.cpp}
// e.g. with KVReconstructedEvent reconEvent:
for(KVEvent::Iterator it = reconEvent.begin(); it != reconEvent.end(); ++it){
   it.get_pointer<KVReconstructedNucleus>()->GetStoppingDetector(); // call KVReconstructedNucleus method
}

// e.g. with KVSimEvent simulEvent:
for(KVEvent::Iterator it = simulEvent.begin(); it != reconEvent.end(); ++it){
   it.get_reference<KVSimNucleus>().GetSpin(); // call KVSimNucleus method
}
~~~~~~~~~


#### Example of nested loop

~~~~~~~~~{.cpp}
// Nested loops over N*(N-1)/2 distinct pairs of particles
for (KVEvent::Iterator it = event.begin(); it != event.end(); ++it) {
   KVEvent::Iterator it2(it);
   for (++it2; it2 != event.end(); ++it2) {
      cout << (*it).GetZ() << "-" << (*it2).GetZ() << " ";
   }
   cout << endl;
}

// possible output:
0-1 0-2 0-3 0-4 0-5 0-6 0-7 0-8 0-9
1-2 1-3 1-4 1-5 1-6 1-7 1-8 1-9
2-3 2-4 2-5 2-6 2-7 2-8 2-9
3-4 3-5 3-6 3-7 3-8 3-9
4-5 4-6 4-7 4-8 4-9
5-6 5-7 5-8 5-9
6-7 6-8 6-9
7-8 7-9
8-9
~~~~~~~~~

#### Iterating over particles which are "OK"

When analysing reconstructed data it is usually required to limit the iteration to only those particles which are considered to be correctly identified/calibrated, i.e. those for which the method
`KVNucleus::IsOK()` returns `true` (see [Nuclei]).

~~~~~~~~~{.cpp}
for(KVEvent::Iterator it = OKEventIterator(event).begin(); it != event.end(); ++it){
   (*it).Print();
}

// with C++11 or later:
for(auto& n : OKEventIterator(event)){
   n.Print();
}
~~~~~~~~~

#### Iterating over particles belonging to a group

If one is only interested in particles which have been previously assigned to some named group, use a `GroupEventIterator`:

~~~~~~~~~{.cpp}
// iterate over particles in group "toto"
for(KVEvent::Iterator it = GroupEventIterator(event,"toto").begin(); it != event.end(); ++it){
   (*it).Print();
}

// with C++11 or later:
for(auto& n : GroupEventIterator(event,"toto")){
   n.Print();
}
~~~~~~~~~

### [deprecated] Using `KVEvent::GetNextParticle()`

This method is kept for backwards compatibility only, you should use the `KVEvent::Iterator` iterators presented above. This method has a dangerous flaw: it uses a global (internal) iterator which means that it is not possible (or desirable) to perform two or more iterations at the same time on the same event (for example, the nested loops iteration in the examples above). 
If you want to easily replace use of this method in old code, you can use new method `KVEvent::GetNextParticleIterator()`:

~~~~~~~~~{.cpp}
/* old code:
 *   KVNucleus* nuc;
 *   while( (nuc = event.GetNextParticle(opt)) ) {
 *
 * replaced with: */
for(KVEvent::Iterator it = event.GetNextParticleIterator(opt); it!=event.end(); ++it) {
   KVNucleus* nuc = it.pointer<KVNucleus>();
~~~~~~~~~

## Defining and using different kinematical reference frames for particles

### Defining and accessing different reference frames for all particles of an event
You can define and use several
different reference frames for the particles in an event. Each
frame can be used independently, and new frames can be defined based on any of the
existing frames:

__Example:__ (for an event accessed through pointer `KVEvent* e`):
 - define a new frame moving at 5 cm/ns in the beam direction:

~~~~~~~~~~~~~~~~~~{.cpp}
e->SetFrame("moving_frame", TVector3(0,0,5));
~~~~~~~~~~~~~~~~~~

 - define a rotated coordinate frame in the "moving_frame", rotated by $90^o$ clockwise around the +ve beam direction:

~~~~~~~~~~~~~~~~~~{.cpp}
TRotation rot;
rot.RotateZ(TMath::PiOver2());
e->SetFrame("rotated_moving_frame", "moving_frame", rot);
~~~~~~~~~~~~~~~~~~

  Note that the same frame can be defined directly from the original frame of all particles in the event by using a combined boost-then-rotation transform:

~~~~~~~~~~~~~~~~~~{.cpp}
e->SetFrame("rotated_moving_frame", KVFrameTransform(TVector3(0,0,5),rot));

// the following only works with C++11 and later
e->SetFrame("rotated_moving_frame", {{0,0,5},rot});
~~~~~~~~~~~~~~~~~~

 - define a similarly rotated coordinate frame in the original (default) reference frame:

~~~~~~~~~~~~~~~~~~{.cpp}
e->SetFrame("rotated_frame", rot);
~~~~~~~~~~~~~~~~~~

 - access kinematical information in any of these frames for any of the particles in the event:

~~~~~~~~~~~~~~~~~~{.cpp}
e->GetParticle(i)->GetFrame("moving_frame")->GetVpar();
e->GetParticle(i)->GetFrame("rotated_frame")->GetPhi();
e->GetParticle(i)->GetFrame("rotated_moving_frame")->GetTransverseEnergy();
~~~~~~~~~~~~~~~~~~

Note that the frame `"rotated_moving_frame"` is directly accessible even if it is defined in two
steps as a rotation of the `"moving_frame"`.

### Changing the default reference frame for all particles in an event
Let us consider an event for which the different reference frames in the previous paragraph have been defined.
Calling method `KVEvent::Print()`{.cpp} will show all reference frames defined for each particle:

~~~~~~~~~~~~~~~~~~{.cpp}
e->Print()

KVParticle mass=939 Theta=45 Phi=0 KE=32.7103 Vpar=5.45392
         moving_frame:  Theta=85.1751 Phi=0 KE=16.6117 Vpar=0.468125
                 rotated_moving_frame:  Theta=85.1751 Phi=270 KE=16.6117 Vpar=0.468125
         rotated_frame:  Theta=45 Phi=270 KE=32.7103 Vpar=5.45392

etc. etc.
~~~~~~~~~~~~~~~~~~

Indentation indicates the relationships between frames: `"rotated_moving_frame"` is a child frame of `"moving_frame"`.
The first line is the default kinematics. As yet it has no name, but if we want we can set a name for the
default kinematics of each particle in the event:

~~~~~~~~~~~~~~~~~~{.cpp}
e->SetFrameName("lab");
~~~~~~~~~~~~~~~~~~

Now if we want to change the default kinematical frame for the event by using `KVEvent::ChangeDefaultFrame()`{.cpp}:

~~~~~~~~~~~~~~~~~~{.cpp}
e->ChangeDefaultFrame("rotated_moving_frame");

e->Print();

KVParticle mass=939 Theta=85.1751 Phi=270 KE=16.6117 Vpar=0.468125
         moving_frame:  Theta=85.1751 Phi=0 KE=16.6117 Vpar=0.468125
                 lab:  Theta=45 Phi=0 KE=32.7103 Vpar=5.45392
                         rotated_frame:  Theta=45 Phi=270 KE=32.7103 Vpar=5.45392
KVNameValueList::ParticleParameters : Parameters associated with a particle in an event (0x7f5a1ff8b1b8)
 <frameName=rotated_moving_frame>
~~~~~~~~~~~~~~~~~~

Note that the name of the default kinematics is stored as a parameter `"frameName"` and can be retrieved with method
`KVEvent::GetFrameName()`{.cpp}.
Note also how the relationships between frames are preserved, i.e. if we present the frames as graphs:

with "lab" as default frame:

~~~~~~
lab
 |
 +--moving_frame
 |        |
 |        +--rotated_moving_frame
 |
 +--rotated_frame
~~~~~~

with "rotated_moving_frame" as default frame:

~~~~~~
rotated_moving_frame
        |
        +--moving_frame
                 |
                 +--lab
                     |
                     +--rotated_frame
~~~~~~



[KVSeqCollection]: http://indra.in2p3.fr/kaliveda/doc/master/classKVSeqCollection.html
[KVList]: http://indra.in2p3.fr/kaliveda/doc/master/classKVList.html
[KVNucleus]: http://indra.in2p3.fr/kaliveda/doc/master/classKVNucleus.html
[KVEvent]: http://indra.in2p3.fr/kaliveda/doc/master/classKVEvent.html
[KVEventViewer]: http://indra.in2p3.fr/kaliveda/doc/master/classKVEventViewer.html
[KVSimNucleus]: http://indra.in2p3.fr/kaliveda/doc/master/classKVSimNucleus.html
[KVSimEvent]: http://indra.in2p3.fr/kaliveda/doc/master/classKVSimEvent.html
[KVReconstructedNucleus]: http://indra.in2p3.fr/kaliveda/doc/master/classKVReconstructedNucleus.html
[KVReconstructedEvent]: http://indra.in2p3.fr/kaliveda/doc/master/classKVReconstructedEvent.html
[Particles]: http://indra.in2p3.fr/kaliveda/doc/master/classKVParticle.html
[Nuclei]: http://indra.in2p3.fr/kaliveda/doc/master/classKVNucleus.html
[Filter]: filter.html
[KVEvent::Iterator]: http://indra.in2p3.fr/kaliveda/doc/master/classKVEvent_1_1Iterator.html
[std::algorithm library]: http://en.cppreference.com/w/cpp/algorithm
[range-based for loop]: http://en.cppreference.com/w/cpp/language/range-for
